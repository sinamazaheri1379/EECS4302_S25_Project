// test-advanced-features.tc
// Tests advanced features, visibility modifiers, static context, and edge cases

// Class with various visibility levels
class BankAccount {
    private float balance;
    private string accountNumber;
    protected string accountType;
    public string ownerName;
    
    private static int totalAccounts = 0;
    public static final float MINIMUM_BALANCE = 100.0;
    
    public BankAccount(string owner, string accNum, float initialBalance) {
        this.ownerName = owner;
        this.accountNumber = accNum;
        this.balance = initialBalance;
        this.accountType = "Savings";
        totalAccounts++;
    }
    
    // Private method
    private boolean validateTransaction(float amount) {
        return amount > 0.0 && (balance - amount) >= MINIMUM_BALANCE;
    }
    
    // Protected method
    protected void logTransaction(string type, float amount) {
        print("Transaction: " + type + " - Amount: " + amount);
    }
    
    // Public methods
    public void deposit(float amount) {
        if (amount > 0.0) {
            balance = balance + amount;
            logTransaction("Deposit", amount);
        }
    }
    
    public boolean withdraw(float amount) {
        if (validateTransaction(amount)) {
            balance = balance - amount;
            logTransaction("Withdrawal", amount);
            return true;
        }
        return false;
    }
    
    public float getBalance() {
        return balance;
    }
    
    // Static method
    public static int getTotalAccounts() {
        return totalAccounts;
    }
    
    // Method with static context error
    public static void staticError() {
        // print(this.balance);  // ERROR: Cannot use 'this' in static context
        // print(balance);       // ERROR: Cannot access instance field from static method
        print("Total accounts: " + totalAccounts);  // OK - static field
    }
}

// Derived class to test protected access
class PremiumAccount extends BankAccount {
    private float creditLimit;
    
    public PremiumAccount(string owner, string accNum, float initial, float limit) {
        super(owner, accNum, initial);
        this.creditLimit = limit;
        this.accountType = "Premium";  // OK - protected in parent
    }
    
    // Override with different visibility (should be checked)
    public void specialWithdraw(float amount) {
        // Can access protected method from parent
        logTransaction("Special Withdrawal", amount);
        
        // Cannot access private field directly
        // float bal = balance;  // ERROR: Cannot access private field
        float bal = getBalance();  // OK - use public method
    }
}

// Test nested scopes and shadowing
class ScopeTest {
    private int x = 10;  // Instance field
    private static int y = 20;  // Static field
    
    public void testScopes(int x) {  // Parameter shadows field
        // Local x shadows parameter
        int x = 5;  // Warning: shadows parameter
        
        {
            int x = 3;  // Another level of shadowing
            print("Inner x: " + x);  // 3
        }
        
        print("Method x: " + x);  // 5
        print("Field x: " + this.x);  // 10
        print("Static y: " + y);  // 20
    }
    
    public void testVariableLifetime() {
        for (int i = 0; i < 5; i++) {
            int loopVar = i * 2;
        }
        // print(i);        // ERROR: i not in scope
        // print(loopVar);  // ERROR: loopVar not in scope
        
        if (true) {
            int ifVar = 42;
        }
        // print(ifVar);    // ERROR: ifVar not in scope
    }
}

// Test method overloading
class OverloadTest {
    public void print(int x) {
        print("Integer: " + x);
    }
    
    public void print(string s) {
        print("String: " + s);
    }
    
    public void print(int x, int y) {
        print("Two integers: " + x + ", " + y);
    }
    
    // Ambiguous overload cases
    public void ambiguous(int x, float y) {
        print("int, float");
    }
    
    public void ambiguous(float x, int y) {
        print("float, int");
    }
    
    // Test overload resolution
    public void testOverloads() {
        print(42);              // Calls print(int)
        print("Hello");         // Calls print(string)
        print(10, 20);          // Calls print(int, int)
        
        // Ambiguous call (should generate error)
        // ambiguous(5, 5);     // ERROR: Ambiguous method call
        
        ambiguous(5, 5.0);      // OK - exact match
        ambiguous(5.0, 5);      // OK - exact match
    }
}

// Test constructor chaining and initialization order
class InitializationTest {
    private static int staticInit = initStatic();
    private int instanceInit = initInstance();
    private int x;
    private int y;
    
    private static int initStatic() {
        print("Static initialization");
        return 1;
    }
    
    private int initInstance() {
        print("Instance initialization");
        return 2;
    }
    
    public InitializationTest() {
        this(0, 0);  // Call other constructor
        print("Default constructor");
    }
    
    public InitializationTest(int x) {
        this(x, 0);  // Call other constructor
        print("Single parameter constructor");
    }
    
    public InitializationTest(int x, int y) {
        this.x = x;
        this.y = y;
        print("Two parameter constructor");
    }
}

// Test final variables and methods
class FinalTest {
    private final int CONSTANT = 42;
    private final string NAME;
    private final int[] ARRAY = {1, 2, 3};
    
    public FinalTest(string name) {
        this.NAME = name;  // OK - initialization in constructor
        // this.CONSTANT = 100;  // ERROR: Already initialized
    }
    
    public void testFinal() {
        // CONSTANT = 50;     // ERROR: Cannot assign to final
        // NAME = "New";      // ERROR: Cannot assign to final
        
        // But array contents can change
        ARRAY[0] = 10;       // OK - modifying content, not reference
        // ARRAY = new int[5]; // ERROR: Cannot change reference
    }
    
    public final void finalMethod() {
        print("This method cannot be overridden");
    }
}

// Test null handling and error cases
void testNullAndErrors() {
    // Null object access
    BankAccount nullAccount = null;
    // nullAccount.deposit(100);  // ERROR: Null pointer dereference
    
    // Null in expressions
    string s = null;
    // string concat = s + "test";  // ERROR: Null pointer
    // int len = s.length();        // ERROR: Null pointer
    
    // Null comparison
    boolean isNull = s == null;     // OK
    boolean notNull = s != null;    // OK
    
    // Array null checks
    int[] nullArray = null;
    // int first = nullArray[0];    // ERROR: Null pointer
    
    // Division by zero
    int zero = 0;
    // int divByZero = 10 / zero;   // ERROR: Division by zero
    float fZero = 0.0;
    float fDiv = 10.0 / fZero;      // Infinity or NaN
}

// Test import functionality
import "test-basic-types.tc";  // Import another file

int main() {
    // Test visibility
    BankAccount acc = new BankAccount("John Doe", "12345", 1000.0);
    acc.deposit(500.0);                 // OK - public method
    // float bal = acc.balance;         // ERROR: Cannot access private field
    float bal = acc.getBalance();       // OK
    string owner = acc.ownerName;       // OK - public field
    
    // Test static access
    int total = BankAccount.getTotalAccounts();
    float min = BankAccount.MINIMUM_BALANCE;
    
    // Test inheritance and protected access
    PremiumAccount premium = new PremiumAccount("Jane Doe", "67890", 5000.0, 2000.0);
    premium.specialWithdraw(100.0);
    
    // Test scopes
    ScopeTest scope = new ScopeTest();
    scope.testScopes(15);
    scope.testVariableLifetime();
    
    // Test overloading
    OverloadTest overload = new OverloadTest();
    overload.testOverloads();
    
    // Test initialization
    InitializationTest init1 = new InitializationTest();
    InitializationTest init2 = new InitializationTest(42);
    
    // Test null and errors
    testNullAndErrors();
    
    return 0;
}